#!/bin/bash
# Dev server wrapper that finds available ports for multi-worktree development
#
# Strategy:
# 1. Scan actual port usage (not files) to find what's in use
# 2. Pick first available port pair (API: 3000+, Web: 5173+)
# 3. Write .ports file for reference (which worktree is where)
# 4. Start dev servers with those ports
# 5. Start HTTP/2 reverse proxy for Electric SQL shape stream multiplexing

set -e

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
ROOT_DIR="$(dirname "$SCRIPT_DIR")"

# Ensure api/.env.local exists
if [ ! -f "$ROOT_DIR/api/.env.local" ]; then
  # Derive database name from worktree/directory name
  WORKTREE_NAME=$(basename "$ROOT_DIR")
  # Convert to valid postgres db name (lowercase, replace non-alphanumeric with _)
  DB_NAME="ship_$(echo "$WORKTREE_NAME" | tr '[:upper:]' '[:lower:]' | tr -c '[:alnum:]' '_' | sed 's/_*$//')"

  echo "Creating api/.env.local with DATABASE_URL for $DB_NAME..."

  # Check if database exists, create if not
  NEEDS_SEED=false
  if ! psql -lqt | cut -d \| -f 1 | grep -qw "$DB_NAME"; then
    echo "Creating database $DB_NAME..."
    createdb "$DB_NAME" 2>/dev/null || {
      echo "ERROR: Could not create database $DB_NAME"
      echo "Please create it manually: createdb $DB_NAME"
      exit 1
    }
    NEEDS_SEED=true
  fi

  cat > "$ROOT_DIR/api/.env.local" << EOF
DATABASE_URL=postgresql://localhost/$DB_NAME
SESSION_SECRET=dev-secret-change-in-production
EOF
  echo "Created api/.env.local"

  # Setup fresh database (schema + seed)
  if [ "$NEEDS_SEED" = true ]; then
    echo "Setting up fresh database..."
    cd "$ROOT_DIR"

    # Ensure dependencies are installed
    if [ ! -d "node_modules" ]; then
      echo "Installing dependencies..."
      pnpm install
    fi

    pnpm build:shared

    # Run migrations (applies schema.sql + all migrations), then seed
    cd "$ROOT_DIR/api"
    DATABASE_URL="postgresql://localhost/$DB_NAME" npx tsx src/db/migrate.ts
    DATABASE_URL="postgresql://localhost/$DB_NAME" npx tsx src/db/seed.ts
    cd "$ROOT_DIR"
    echo "Database setup complete!"
  fi
fi

# Base ports
API_BASE=3000
WEB_BASE=5173
H2_BASE=4443

# Find an available port starting from base
find_available_port() {
  local base=$1
  local port=$base
  local max_attempts=20

  for ((i=0; i<max_attempts; i++)); do
    if ! lsof -i:$port >/dev/null 2>&1; then
      echo $port
      return 0
    fi
    ((port++))
  done

  echo "ERROR: Could not find available port after $max_attempts attempts (starting from $base)" >&2
  return 1
}

# Find available ports
echo "Finding available ports..."
API_PORT=$(find_available_port $API_BASE)
WEB_PORT=$(find_available_port $WEB_BASE)
H2_PORT=$(find_available_port $H2_BASE)

echo "Using API port: $API_PORT"
echo "Using Web port: $WEB_PORT"
echo "Using H2 proxy port: $H2_PORT"

# Generate TLS certs for the HTTP/2 proxy (no-op if already present)
bash "$SCRIPT_DIR/generate-dev-certs.sh"

# Write .ports file for reference
cat > "$ROOT_DIR/.ports" << EOF
# Auto-generated by scripts/dev.sh
# This file shows which ports this worktree's dev server is using
# DO NOT EDIT - will be overwritten on next dev start
API=$API_PORT
WEB=$WEB_PORT
H2=$H2_PORT
STARTED=$(date -Iseconds)
WORKTREE=$(basename "$ROOT_DIR")
EOF

echo "Wrote .ports file"

# Clean up .ports file on exit
cleanup() {
  if [ -f "$ROOT_DIR/.ports" ]; then
    rm -f "$ROOT_DIR/.ports"
    echo "Cleaned up .ports file"
  fi
}
trap cleanup EXIT INT TERM

# Export environment variables and start dev servers
# Note: VITE_API_URL is intentionally unset so API calls use relative URLs
# and go through the Vite proxy. This is required for the HTTP/2 proxy to work
# (all requests must be same-origin for cookie/auth to work over HTTP/2).
export PORT=$API_PORT
export CORS_ORIGIN="https://localhost:$H2_PORT"
export VITE_PORT=$WEB_PORT
export H2_PORT=$H2_PORT

echo ""
echo "Starting dev servers..."
echo "  API:      http://localhost:$API_PORT"
echo "  Vite:     http://localhost:$WEB_PORT (internal)"
echo "  ────────────────────────────────────────────"
echo "  Open:     https://localhost:$H2_PORT  (HTTP/2)"
echo ""

cd "$ROOT_DIR"

# Start the HTTP/2 proxy in the background alongside pnpm dev
node "$SCRIPT_DIR/h2-dev-proxy.mjs" &
H2_PID=$!

# Ensure the H2 proxy is killed on exit
cleanup_all() {
  kill $H2_PID 2>/dev/null || true
  if [ -f "$ROOT_DIR/.ports" ]; then
    rm -f "$ROOT_DIR/.ports"
    echo "Cleaned up .ports file"
  fi
}
trap cleanup_all EXIT INT TERM

pnpm --parallel --recursive run dev
